from plotter import Plotter
import matplotlib.pyplot as plt


# Class to read the input file of points and polygon
# filename input takes a csv file
class ReadFile:

    def __init__(self, filename):
        self.filename = "filename"

    def access_csv_file(self, pt_x, pt_y):  # Splits data into two lists of x and y for points
        try:
            with open(self, 'r') as f:
                lines = f.readlines()[1:]  # Removes the first line (id,x,y)
                for line in lines:
                    line = line.strip().split(',')  # Separates values by commas
                    pt_x.append(float(line[1]))
                    pt_y.append(float(line[2]))
        except IOError:
            print("Unable to read this file")  # Error handling feature if the file is not readable     

    # Function to merge x and y lists, in to lists  [x,y
    try:
        def generate_coordinates(self, p_x, p_y):
            return list(map(lambda x, y: (x, y), p_x, p_y))
    except IOError:
        print("Unable to create coordinates")  # Error handling feature   


# Function to define minimum and maximum bounds of the polygon
# provides an output that states the location of the
# True - Inside, 1 - Boundary, False - Outside
def minimum_bound(p_x, p_y, a_x, a_y):
    if min(a_x) < p_x < max(a_x) and min(a_y) < p_y < max(a_y):  # is the point within the bounds of the box
        return True
    elif min(a_x) == p_x and min(a_y) <= p_y <= max(a_y):
        return 1  # if point x is equal to minimum x value, and between y values
    elif max(a_x) == p_x and min(a_y) <= p_y <= max(a_y):
        return 1
    elif min(a_y) == p_y and min(a_x) <= p_x <= max(a_x):  # if point y is equal to minimum y value -
        return 1  # and between x values
    elif max(a_y) == p_y and min(a_x) <= p_x <= max(a_x):  # if point y is equal to maximum y value -
        return 1  # and between x values
    else:
        return False  # None of the parameters are met


# This code is patterned after [Franklin, 2000]
# Taken from: http://geomalgorithms.com/a03-_inclusion.html
def ray_casting(pt, pg):  # Takes arguments pt - Point[x,y] and sh - polygon [x,y]
    n = len(pg) - 1  # Generated by the generate_coordinates()
    counter = 0  # Set counter to zero
    for j in range(n):  # loop through polygon lines
        if (pg[j][1] <= pt[1] < pg[j + 1][1]) or (pg[j][1] > pt[1] >= pg[j + 1][1]):  # compute point of intersection
            vt = (pt[1] - pg[j][1]) / (pg[j + 1][1] - pg[j][1])  # compute intersect coordinate
            if pt[0] < (pg[j][0] + vt * (pg[j + 1][0] - pg[j][0])):  # right / left intersect
                counter += 1
        j += 1
    return counter  # Returns the number of lines crossed


# Test for if the point is on the line
# p_x / p_y  - x / y value of point
# a_x / a_y  - x / y value of start point of line
# b_x / b_y  - x / y value of end point of line
def is_on_line(p_x, p_y, a_x, a_y, b_x, b_y):
    if not ((a_y <= p_y <= b_y or b_y <= p_y <= a_y) and (a_x <= p_x <= b_x or b_x <= p_x <= a_x)):
        return False
    elif a_x == b_x and p_x == a_x:  # if segment is parallel to y axis
        return True
    elif a_x != b_x and compute_y(p_x, a_x, a_y, b_x, b_y) == p_y:  # if point is on a non parallel line
        return True  # Point is on line
    else:
        return False  # Point is not on line


def compute_y(x, x1, y1, x2, y2):  # Runs arguments through 'point on a line' equation
    return (x - x1) / (x2 - x1) * (y2 - y1) + y1


# Function to call 'minimum bound', 'ray casting' and 'point on a line' functions
# Locates a bound with respect to the polygon
# p_x / p_y  - x / y value of point
# a_x / a_y  - x / y value of start point of line
# b_x / b_y  - x / y value of end point of line
# s / p      - [x,y] format from generate_coordinate() function
def locate_points(p_x, p_y, s_x, s_y, pg, pt, loc):
    for k in range(len(loc)):
        if not minimum_bound(p_x[k], p_y[k], s_x, s_y):  # if points are outside maximum bound
            loc[k] = "outside"
        elif (ray_casting(pt[k], pg)) % 2 != 0:  # Points tested by ray casting
            loc[k] = "inside"  # Assign the string "inside" to the location list
        else:
            loc[k] = "outside"  # Assign the string "outside" to the location list
        for j in range(len(s_x) - 1):
            if is_on_line(p_x[k], p_y[k], s_x[j], s_y[j], s_x[j + 1], s_y[j + 1]):  # Points tested by "point on line"
                loc[k] = "boundary"  # Assign the string "boundary" to the location list


def locate_point(p_x, p_y, s_x, s_y, pt, pg, loc):
    if (ray_casting(pt, pg)) % 2 != 0:  # Points tested by ray casting
        loc[0] = "inside"  # Assign the string "inside" to the location variable
    else:
        loc[0] = "outside"  # Assign the string "outside" to the location variable
    for j in range(len(s_x) - 1):
        if is_on_line(p_x, p_y, s_x[j], s_y[j], s_x[j + 1], s_y[j + 1]):  # Points tested by "point on line algorithm"
            loc[0] = "boundary"  # Assign the string "boundary" to the location variable


# # Function to merge x and y lists, in to lists  [x,y]
# def generate_coordinates(p_x, p_y):
#     return list(map(lambda x, y: (x, y), p_x, p_y))


if __name__ == "__main__":

    point_x = []
    point_y = []
    shape_x = []
    shape_y = []

    # Use ReadFile class to access the data within the csv files
    ReadFile.access_csv_file("polygon.csv", shape_x, shape_y)
    ReadFile.access_csv_file("input.csv", point_x, point_y)

    # Set the location list to 100 None values, to be iterated over
    category = [None] * len(point_x)

    # x and y points converted into tuple format for ray casting algorithm
    p = ReadFile.generate_coordinates("input.csv", point_x, point_y)
    s = ReadFile.generate_coordinates("polygon.csv", shape_x, shape_y)

    # Locate_points() function applied to iterate point location over location list
    locate_points(point_x, point_y, shape_x, shape_y, s, p, category)

    # Points plotted with locations
    plotter = Plotter()
    # Loop over each point
    for i in range(len(point_x)):
        plotter.add_point(point_x[i], point_y[i], category[i])
    plotter.add_polygon(shape_x, shape_y)
    plt.plot(shape_x, shape_y)
    # Apply some annotations
    plt.xlabel("x")
    plt.ylabel("y")
    plt.title("Point in Polygon Test")
    plotter.show()


    # Create an index column to write into a csv file
    id = []
    i = 0
    while i < 101:
        id.append(i)
        i += 1
    id[0] = "id"
    print(id)

    a = "Category"
    category.insert(0, a)
    print(category)

    # file = open("output.txt", "w")
    # for index in range(len(a)):
    #     file.write(str(id) + ", " + str(category) + "\n")
    # file.close()


    # Write the output to a csv file
    output_file = open("output.csv", "w")
    for i in range(len(category)):
        output_file.write(category[i] + "," + id[i] + "\n")
   





